# TODO: Use mask patterns generated by depth_order_bilinear_forward_warp()
# NOTE: eval data is not static. all data is dynamically generated.
import torch
import torch.nn.functional as F
from torch.utils.data.dataset import Dataset
from torchvision.transforms import (
    functional as TF,
    InterpolationMode,
)
import torchvision.transforms as T
import nunif.transforms.std as TS
from nunif.utils.image_loader import ImageLoader
from nunif.utils.pil_io import load_image_simple
import random
import math


SIZE = 256  # % 8 == 0


def edge_weight(x):
    assert x.ndim == 4
    max_v = F.max_pool2d(x, kernel_size=3, stride=1, padding=1)
    min_v = F.max_pool2d(x.neg(), kernel_size=3, stride=1, padding=1).neg()
    range_v = max_v - min_v
    range_c = range_v - range_v.mean(dim=[1, 2, 3], keepdim=True)
    range_s = range_c.pow(2).mean(dim=[1, 2, 3], keepdim=True).sqrt()
    w = (range_c / (range_s + 1e-6)).clamp(-3, 3)
    w_min, w_max = w.amin(dim=[1, 2, 3], keepdim=True), w.amax(dim=[1, 2, 3], keepdim=True)
    w = (w - w_min) / ((w_max - w_min) + 1e-6)

    return w


def random_edge(x):
    x = x.unsqueeze(0)
    kernel = torch.tensor([[1, 1, 0, -1, -1] * 5], dtype=x.dtype, device=x.device).view(1, 1, 5, 5)
    gray = x.mean(dim=1, keepdim=True)
    horizontal = True
    if False:  # random.random() > 0.5:
        kernel = kernel.permute(0, 1, 3, 2)
        horizontal = False

    edge = F.conv2d(gray, weight=kernel)
    edge = edge_weight(edge) > 0.9
    edge = F.pad(edge, (2,) * 4)
    if random.random() < 0.85:
        step = random.randint(1, 16)
        sign = random.choice([-1, 1])
        edge = F.pad(F.pad(edge, (step * sign, 0, 0, 0)), (0, step * sign * -1, 0, 0))

    step2 = random.choice([0, 0, 1, 2, 3])
    sign2 = random.choice([-1, 1])

    n = random.randint(1, 2)
    for i in range(n):
        step = random.randint(2, 16)
        sign = random.choice([-1, 1])
        if horizontal:
            edge = edge | F.pad(F.pad(edge, (step * sign, 0, 0, 0)), (0, step * sign * -1, 0, 0))
            edge = edge | F.pad(F.pad(edge, (0, 0, step2 * sign2, 0)), (0, 0, 0, step2 * sign2 * -1))
        else:
            edge = edge | F.pad(F.pad(edge, (0, 0, step * sign, 0)), (0, 0, 0, step * sign * -1))
            edge = edge | F.pad(F.pad(edge, (step2 * sign2, 0, 0, 0)), (0, step2 * sign2 * -1, 0, 0))

    return edge.squeeze(0).to(x.dtype)


def draw_line(block, p1, p2, fg, size, size_step):
    steps = math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)
    if not size_step:
        pass
    else:
        steps = steps / size
    steps = int(steps)
    if steps == 0:
        return p1

    y_delta = (p2[0] - p1[0]) / steps
    x_delta = (p2[1] - p1[1]) / steps
    p = p1
    last_p = None
    for _ in range(steps):
        last_p = [int(p[0]), int(p[1])]
        for y in range(size):
            y = min(y + last_p[0], block.shape[1] - 1)
            for x in range(size):
                x = min(x + last_p[1], block.shape[2] - 1)
                block[:, y, x] = fg
        p[0] += y_delta
        p[1] += x_delta
    return last_p


def draw_random_line(x, fg, size):
    block_size = min(x.shape[1], x.shape[2])
    num_points = random.randint(2, 12)
    points = []
    for i in range(num_points):
        points.append([random.randint(0, block_size - 1), random.randint(0, block_size - 1)])
    if random.random() < 0.5:
        if random.random() < 0.5:
            points = sorted(points, key=lambda p: p[0])
        else:
            points = sorted(points, key=lambda p: p[1])
    else:
        random.shuffle(points)

    H, W = x.shape[1:]
    mask = torch.zeros((1, H, W), dtype=x.dtype, device=x.device)
    p = points[0]
    for next_p in points[1:]:
        p = draw_line(mask, p, next_p, fg, size, size_step=True)

    return mask


def apply_random_mask(x):
    C, H, W = x.shape

    method = random.randint(0, 3)
    if method == 0:
        p = random.uniform(0.01, 0.1)
        scale_h = random.choice([1, 2, 4, 5, 8])
        scale_w = random.choice([1, 2, 4, 5, 8])

        p = torch.empty((1, H // scale_h, W // scale_w), dtype=x.dtype, device=x.device).fill_(p)
        mask = torch.bernoulli(p)
        mask = TF.resize(mask, (H, W), interpolation=InterpolationMode.NEAREST)
        if random.random() < 0.5:
            mask2 = TF.rotate(mask, angle=random.uniform(-60, 60))
            if random.random() < 0.5:
                mask = ((mask >= 0.5) | (mask2 >= 0.5)).to(x.dtype)
            else:
                mask = (mask2 >= 0.5).to(x.dtype)
        else:
            mask = (mask >= 0.5).to(x.dtype)
    elif method == 1:
        p = random.uniform(0.001, 0.03)
        if random.random() < 0.5:
            scale_h = random.randint(4, 32)
            scale_w = random.choice([1, 2, 3, 4])
        else:
            scale_h = random.choice([1, 2, 3, 4])
            scale_w = random.randint(4, 32)

        p = torch.empty((1, H // scale_h, W // scale_w), dtype=x.dtype, device=x.device).fill_(p)
        mask = torch.bernoulli(p)
        mask = TF.resize(mask, (H, W), interpolation=InterpolationMode.NEAREST)
        mask = TF.rotate(mask, angle=random.uniform(-45, 45))
        mask = (mask >= 0.5).to(x.dtype)
    elif method == 2:
        mask = random_edge(x)
    elif method == 3:
        size = random.randint(1, 8)
        mask = draw_random_line(x, 1.0, size)

    if random.random() < 0.1:
        if random.random() < 0.5:
            mask[:, 0::2, :] = 0
        else:
            mask[:, :, 1::2] = 0
        mask = TF.rotate(mask, angle=random.uniform(-15, 15))
        mask = (mask >= 0.5).to(x.dtype)

    # x = x * (1 - mask) + (mask * torch.rand((3, 1, 1), dtype=x.dtype, device=x.device))
    x = x * (1 - mask)  # black mask
    mask = mask.to(torch.bool)

    return x, mask


class RandomWidthStretch():
    def __call__(self, im):
        width, height = im.size
        scale = random.uniform(1.0, 2.0)
        resized = TF.resize(im, (height, int(width * scale)), interpolation=InterpolationMode.BILINEAR)
        im = TF.crop(resized, 0, 0, height, width)
        return im


class InpaintDataset(Dataset):
    def __init__(self, input_dir, model_offset, training):
        super().__init__()
        self.training = training
        self.model_offset = model_offset
        self.files = list(ImageLoader.listdir(input_dir))
        if not self.files:
            raise RuntimeError(f"{input_dir} is empty")

        self.gt_transform = T.Compose([
            TS.RandomSRHardExampleCrop(SIZE),
            T.RandomApply([TS.RandomGrayscale()], 0.005),
            TS.RandomFlip(),
            T.RandomApply([RandomWidthStretch()], 0.5),
        ])

    def worker_init(self, worker_id):
        pass

    def __len__(self):
        return len(self.files)

    def __getitem__(self, index):
        im, _ = load_image_simple(self.files[index], color="rgb")
        im = self.gt_transform(im)
        x = TF.to_tensor(im)
        x, mask = apply_random_mask(x)
        y = TF.to_tensor(TF.crop(im, self.model_offset, self.model_offset,
                                 im.height - self.model_offset * 2,
                                 im.width - self.model_offset * 2))
        return x, mask, y, index


def _test():
    import torchvision.io as io
    import time

    src = io.read_image("cc0/320/dog.png") / 255.0
    for _ in range(4):
        x, mask = apply_random_mask(src)
        TF.to_pil_image(x).show()
        time.sleep(2)


if __name__ == "__main__":
    _test()
